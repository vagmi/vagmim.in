<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lisp sap abap | Vagmi's Blog]]></title>
  <link href="http://vagmim.in/blog/categories/lisp-sap-abap/atom.xml" rel="self"/>
  <link href="http://vagmim.in/"/>
  <updated>2012-11-20T00:27:22+05:30</updated>
  <id>http://vagmim.in/</id>
  <author>
    <name><![CDATA[Vagmi Mudumbai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Need for a business language]]></title>
    <link href="http://vagmim.in/blog/2008/04/30/need-for-business-language/"/>
    <updated>2008-04-30T00:00:00+05:30</updated>
    <id>http://vagmim.in/blog/2008/04/30/need-for-business-language</id>
    <content type="html"><![CDATA[<div class='post'>
As many of my readers already know, I work for <a href="http://en.wikipedia.org/wiki/SAP_AG#SAP_Labs">SAP</a>. It is my personal belief that SAP R/3 is so successful only because of its ABAP system. The language provides the right level of abstraction and has appropriate tooling to build business applications. I learned <a href="http://en.wikipedia.org/wiki/Abap">ABAP</a> only a year before (while I have been with SAP for over 3 years now). I was amazed by the speed and agility with which you could create a database driven application and expose your business logic to the outside world in minutes. <br /><br />The language, as any old language, has its idiosyncracies. But the way it handles database interactions with transparent and internal tables and "Open SQL" is really cool. I haven't programmed in the OO version of ABAP yet. But at initial glance it seems to have been corrupted by the idea of OO from C++ and Java. No one could have put it more adequately than Alan Kay himself.<br /><br /><blockquote><br />I invented the term Object-Oriented, and I can tell you I did not have C++ in mind. -- Alan Kay<br /></blockquote><br /><br />As we move on to the new decade, we are in need of a language that is closer to the business roots. A language that can be molded to best describe the problems in the business domain. As a hacker, the language that immediately comes to my mind is Lisp. Unfortunately, Lisp is not taught in schools as much it should be taught. <br /><br />In an excellent <a href="http://www.stsc.hill.af.mil/CrossTalk/2008/01/0801DewarSchonberg.html">essay</a> by the folks from AdaCore, they express their concerns about using Java as the first language that is taught to programmers.<br /><br /><blockquote><br />It is our view that Computer Science (CS) education is neglecting basic skills, in particular in the areas of programming and formal methods. We consider that the general adoption of Java as a first programming language is in part responsible for this decline. We examine briefly the set of programming skills that should be part of every software professional’s repertoire. <br /></blockquote><br /><br />Further in the essay they insist on why Lisp still matters. (Emphasis mine.)<br /><br /><blockquote><br />Why Lisp Matters<br /><br />Every programmer must be comfortable with functional programming and with the important notion of referential transparency. Even though most programmers find imperative programming more intuitive, they must recognize that in many contexts that a functional, stateless style is clear, natural, easy to understand, and efficient to boot.<br /><br />An additional benefit of the practice of Lisp is that the program is written in what amounts to abstract syntax, namely the internal representation that most compilers use between parsing and code generation. Knowing Lisp is thus an excellent preparation for any software work that involves language processing.<br /><br />Finally, Lisp (at least in its lean Scheme incarnation) is amenable to a very compact self-definition. <b>Seeing a complete Lisp interpreter written in Lisp is an intellectual revelation that all computer scientists should experience.</b><br /></blockquote><br /><br />Page 13 of this <a href="http://books.google.co.in/books?id=68j6lEJjMQwC&pg=PA76&lpg=PA76&dq=lisp+1.5+programmers+manual&source=web&ots=Ihq8m-_uyo&sig=mgiTYn_VR6YzpeLuV8JRl4deWvE&hl=en#PPA13,M1">book</a>(PDF) by John McCarthy is literally the source of intellectual revelation.<br /><br />Eric Raymond's <a href="http://catb.org/~esr/faqs/hacker-howto.html">essay</a> was one of the reasons that I started learning Lisp. He has the following opinion on Lisp.<br /><br /><blockquote><br />LISP is worth learning for a different reason — the profound enlightenment experience you will have when you finally get it. That experience will make you a better programmer for the rest of your days, even if you never actually use LISP itself a lot. <br /></blockquote><br /><br />I strongly suspect that the source of the "profound enlightenment experience" lies somewhere in understanding the code in Page 13 of the book.<br /><br />I do not insist that the new business language has to be lisp. But lisp is the only language that satisfies such criteria. Problem domains keep changing and the by far the only language that is agile enough and malleable to fit the problem domain is lisp. Note that I am not saying that we would have to use Scheme, Common Lisp or Arc. I am just saying that we need a language similar to these. It could as well be a lisp written on top of any of these lisps, CLR or JVM. What matters here is the language - a formal notion to express our ideas. The compiler, VM and the platform are implementation details. Paul Graham explains this nicely in a rather long essay titled "The Hundred-Year Language".<br /><br />But you might argue that Java and C++ are established languages. People are creating enterprise software with Java and C++. Why should we change? But look at the enterprise software carefully. Most of what took man years to implement in Java/C++ could have been achieved with much less effort using Lisp. Or if the system was well designed using the popular knowledge of design patterns that has evolved in the community, you would have created half of the abstractions present in lisp anyway. This is called the <a href="http://en.wikipedia.org/wiki/Greenspun%27s_Tenth_Rule">Greenspun's Tenth Rule of Programming</a>. Although it explicitly states C or Fortran, I believe that it holds good for languages like Java too.<br /><br /><blockquote><br />"Greenspun's Tenth Rule of Programming: any sufficiently complicated C or Fortran program contains an ad hoc informally-specified bug-ridden slow implementation of half of Common Lisp."<br /><br />- Philip Greenspun<br /></blockquote><br /><br />Even the co-auther of the Java language spec, Guy Steele, <a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg04045.html">accepts</a> that Java is no match for the features in Lisp.<br /><br /><blockquote><br />And you're right: we were not out to win over the Lisp programmers; we were after the C++ programmers.  We managed to drag a lot of them about halfway to Lisp.  Aren't you happy? -- Guy Steele<br /></blockquote><br /><br />Why are we still targeting Java as the language of choice to build business applications? The cool kids have already moved to Ruby. But wait, I heard Matz said something about lisp.<br /><br /><blockquote><br />Some may say Ruby is a bad rip-off of Lisp or Smalltalk, and I admit that. But it is nicer to ordinary people. - <a href="http://en.wikipedia.org/wiki/Yukihiro_Matsumoto">Matz</a><br /></blockquote><br /><br />Its time to revive the 50 year old language and start to rediscover the language used by our previous generation.<br /><br /><a href="http://xkcd.com/297/"> <br /><img src="http://imgs.xkcd.com/comics/lisp_cycles.png"> <br /></a><br /><br />As <a href="http://en.wikipedia.org/wiki/Kernighan">Kernighan</a> and <a href="http://en.wikipedia.org/wiki/Dennis_Ritchie">Ritchie</a> once suggested -<br /><br /><blockquote><br />The only way to learn a new programming language is by writing programs in it. - K&R<br /></blockquote><br /><br />Keep coding. You know I am (in Lisp).</div>

]]></content>
  </entry>
  
</feed>
