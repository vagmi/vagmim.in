---
layout: post
title: "Getting started with clojure"
date: 2012-12-10 17:18
comments: true
---
I have been playing around with [clojure](http://clojure.org/) for a bit now and I can postively say that I am absolutely floored. I have always favored dynamic and more expressive languages. I have a rather unfortunate situation of working with a Java codebase. I like the JVM and the [tools](http://docs.oracle.com/javase/6/docs/technotes/tools/share/jvisualvm.html) around it but not the language itself. I have always been fond of lisp. Ever since I read ["How to be a hacker"](http://www.catb.org/esr/faqs/hacker-howto.html) by Eric Raymond, I wanted to learn both lisp and python. Picking up python was easy. It took my barely a week until I could write a web app in python. With Ruby and Rails the transition was even smoother. My forays into the Lisp world were not that fruitful. I learned both Common Lisp and PLT Scheme. I found that I liked Scheme better than CL. In fact the only lisp I found myself using regularly was elisp. For anything useful in the sense of hacking, I found I was using python a lot. Was lisp then merely an academic language? I had read John McCarthy's [initial paper](http://www-formal.stanford.edu/jmc/recursive.pdf) and was awed by its simplicity. In the meanwhile I had devoured books and articles on lisp its macros and was even able to appreciate the flamewars about [hygenic macros](http://www.cs.indiana.edu/~dyb/pubs/tr356.pdf) and [CLOS](http://www.cs.oswego.edu/~blue/xex/black/courses/f06/ai1/ECOOP.pdf). However, I could not do serious stuff with lisp. I found lisp very had to smuggle in to enterprises. Python and Ruby were far easier to be sold.

Then I met clojure. From its first sight, I knew it was beautiful. It implemented both the CLOS parts with defmulti and hygenic macros from the scheme land. It had nice set of special forms to provide just enough syntactic sugar to be expressive without breaking the language too much. But what is more fascinating about Clojure is that it gets concurrency right. It uses persistent and [immutable data structures](http://clojure.org/state) that can be shared across callers. It provides a sane implementation of [STM](http://clojure.org/refs) and ties it in beautifully concepts like futures and promises. Its Java interop makes interacting with Java libraries amazingly laconic with macros like the expression threading macro and the dot macros. Bottlenecks that you may have in your code due to the dynamic nature can be easily optimized away using type hinting. And in the Java land there is a library for literally everything. It may not have a nice DSL but thats where clojure comes in.

Ousterhout had formulated a dichotomy between powerful statically typed languages or system programming languages and the expressive dynamically typed languages. With clojure that distinction does not exist or is very nearly invisible. Clojure almost always errs on the side of better performance. At this point, I happen to be working with quite a large dataset that needs to be kept in memory and uses complicated graph traversals using Neo4j. Clojure handles this without breaking a sweat. Similar code written in plain Java would be quite complicated and I was not able to get nearly enough performance with JRuby despite several tricks.

In short, what is your excuse for not using clojure?
