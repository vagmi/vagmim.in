---
layout: post
title: "Spying on Registry Entries"
date: 2004-12-01
comments: false
---

<div class='post'>
<P>I am probably letting out the best kept secret of installation industry. I always used to wonder and have now discovered how most of the installation tools spy on registry entries that are created during COM registration or similar processes without actually affecting the build system. The spying program creates temporary registry keys for each of the registry hives HKCR, HKLM, HKCU, HKU and it maps the registry hives to these temporary registry keys. It then triggers the registration function which creates registry entries withing the registry keys specified instead of including it in the hives. I came across this revelation while I was wading through the source code for Tallow in the WIX toolset.</P><br /><P>The core of this spying exercise relies on functions exposed by the advapi32.dll. The actual hive to key mapping is performed by the <A href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/sysinfo/base/regoverridepredefkey.asp">RegOverridePredefKey()</A> function. The handle to the registry key is passed by using the <A href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/sysinfo/base/regcreatekeyex.asp">RegCreateKeyEx()</A> or the <A href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/sysinfo/base/regopenkeyex.asp">RegOpenKeyEx()</A> function. After the mapping is done, you can invoke the DllRegisterServer() function after loading the library using the <A href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/loadlibrary.asp">LoadLibrary()</A> function. This mapping would be active for all the registry entries created by that particular process. So out of process registration for exe files may not directly work with this method. For the sake of simplicity, I am going to extract COM Interop settings from a given assembly. So let us write a simple console app in C# to do this. This app would perform the mapping and write the registry entries to a REG file and wipe out the key after the file is written.</P><br /><P>Extracting registration information from a DLL file is similar but involve the importing other functions from Kernel32.dll. So I am giving that a raincheck now. You can download the Wix toolset's source package if you are interested. To start off with, let us write a class with static members to import the functions from advapi32.dll and create wrappers for them. Ensure that you have <A href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemruntimeinteropservices.asp">System.Runtime.InteropServices</A> namespace included.</P><br /><DIV class=cf><br /><P class=cl>&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>class</FONT></SPAN> OverRideRegistry<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//We first declare some stuff required. The are defined in winreg.h and windows.h<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>static</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>readonly</FONT></SPAN> UIntPtr HkeyClassesRoot = (UIntPtr)0x80000000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>static</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>readonly</FONT></SPAN> UIntPtr HkeyCurrentUser = (UIntPtr)0x80000001;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>static</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>readonly</FONT></SPAN> UIntPtr HkeyLocalMachine = (UIntPtr)0x80000002;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>static</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>readonly</FONT></SPAN> UIntPtr HkeyUsers = (UIntPtr)0x80000003;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>const</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> Delete = 0x00010000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>const</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> ReadOnly = 0x00020000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>const</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> WriteDac = 0x00040000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>const</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> WriteOwner = 0x00080000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>const</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> Synchronize = 0x00100000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>const</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> StandardRightsRequired = 0x000F0000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>const</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> StandardRightsAll = 0x001F0000;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>const</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> GenericRead = 0x80000000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>const</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> GenericWrite = 0x40000000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>const</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> GenericExecute = 0x20000000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>const</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> GenericAll = 0x10000000;<BR><SPAN class=cb1><FONT color=#0000ff><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #region</FONT></SPAN> The Interop Import Stuff<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//we now import the functions exposed by advapi32.dll<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//Use RegCreateKeyEx to get handle to the openedKey<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("advapi32.dll", EntryPoint="RegCreateKeyExW", CharSet=CharSet.Unicode, ExactSpelling=<SPAN class=cb1><FONT color=#0000ff>true</FONT></SPAN>, SetLastError=<SPAN class=cb1><FONT color=#0000ff>true</FONT></SPAN>)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>internal</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>static</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>extern</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>int</FONT></SPAN> RegCreateKey(UIntPtr key, <SPAN class=cb1><FONT color=#0000ff>string</FONT></SPAN> subkey, <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> reserved, <SPAN class=cb1><FONT color=#0000ff>string</FONT></SPAN> className, <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> options, <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> desiredSam, <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> securityAttributes, <SPAN class=cb1><FONT color=#0000ff>out</FONT></SPAN> IntPtr openedKey, <SPAN class=cb1><FONT color=#0000ff>out</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> disposition);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//This does the actual hive to key mapping<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("advapi32.dll", EntryPoint="RegOverridePredefKey", CharSet=CharSet.Unicode, ExactSpelling=<SPAN class=cb1><FONT color=#0000ff>true</FONT></SPAN>, SetLastError=<SPAN class=cb1><FONT color=#0000ff>true</FONT></SPAN>)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>internal</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>static</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>extern</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>int</FONT></SPAN> RegOverridePredefKey(UIntPtr key, IntPtr newKey);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//Like good programmers, we release our handles.<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("advapi32.dll", EntryPoint="RegCloseKey", CharSet=CharSet.Unicode, ExactSpelling=<SPAN class=cb1><FONT color=#0000ff>true</FONT></SPAN>, SetLastError=<SPAN class=cb1><FONT color=#0000ff>true</FONT></SPAN>)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>internal</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>static</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>extern</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>int</FONT></SPAN> RegCloseKey(IntPtr key);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//Our interops are done :-)<BR></FONT></SPAN><SPAN class=cb1><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endregion<BR></FONT></SPAN><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//Now we actually write wrapper functions to use the imported functions<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//Wrapper for creating Registry Keys<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>internal</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>static</FONT></SPAN> IntPtr OpenRegistryKey(UIntPtr key, <SPAN class=cb1><FONT color=#0000ff>string</FONT></SPAN> path)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IntPtr newKey = IntPtr.Zero;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> disposition = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>uint</FONT></SPAN> security = StandardRightsAll | GenericRead | GenericWrite | GenericExecute | GenericAll;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>int</FONT></SPAN> error = RegCreateKey(key, path, 0, <SPAN class=cb1><FONT color=#0000ff>null</FONT></SPAN>, 0, security, 0, <SPAN class=cb1><FONT color=#0000ff>out</FONT></SPAN> newKey, <SPAN class=cb1><FONT color=#0000ff>out</FONT></SPAN> disposition);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>return</FONT></SPAN> newKey;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//Wrapper for the mapping<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>internal</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>static</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>void</FONT></SPAN> OverrideRegistryKey(UIntPtr key, IntPtr newKey)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>int</FONT></SPAN> error = RegOverridePredefKey(key, newKey);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//Wrapper for freeing the handle<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>internal</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>static</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>void</FONT></SPAN> CloseRegistryKey(IntPtr key)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>int</FONT></SPAN> error = RegCloseKey(key);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P><br /><P class=cl>Now that we have the helper class with the static methods, we can define our main Console App class, which would use the functions in the helper class to register the assembly and steal the registry entries. Let us define the functions that Map and Map the registry hives. I had initialized the RegLocation to a string "Software\\Vagmi\\RegInterop\\". So the extracted registry entries would be put in the HKLM hive within the specified path. Also not that I have mapped HKLM as the final mapping. Else all keys that are subsequently created would be created within our registry key.</P><br /><DIV class=cf><br /><P class=cl>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>void</FONT></SPAN> MapRegHives()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapRegHive(OverRideRegistry.HkeyClassesRoot,<SPAN class=cb1><FONT color=#0000ff>this</FONT></SPAN>.RegLocation+"HKCR");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapRegHive(OverRideRegistry.HkeyCurrentUser,<SPAN class=cb1><FONT color=#0000ff>this</FONT></SPAN>.RegLocation+"HKCU");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapRegHive(OverRideRegistry.HkeyUsers,<SPAN class=cb1><FONT color=#0000ff>this</FONT></SPAN>.RegLocation+"HKU");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapRegHive(OverRideRegistry.HkeyLocalMachine,<SPAN class=cb1><FONT color=#0000ff>this</FONT></SPAN>.RegLocation+"HKLM");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>void</FONT></SPAN> MapRegHive(UIntPtr key, <SPAN class=cb1><FONT color=#0000ff>string</FONT></SPAN> location)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine("Mapping " + key + "&nbsp; to " + location);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IntPtr createdKey=IntPtr.Zero;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>try<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; createdKey=OverRideRegistry.OpenRegistryKey(OverRideRegistry.HkeyLocalMachine,location);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OverRideRegistry.OverrideRegistryKey(key,createdKey);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>catch</FONT></SPAN>(Exception e)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine("Caught exception: " + e.Message);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>finally<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//close key like responsible programmers<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OverRideRegistry.CloseRegistryKey(createdKey);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//Functions to unmap registry hives.<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>void</FONT></SPAN> UnMapRegHives()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OverRideRegistry.OverrideRegistryKey(OverRideRegistry.HkeyClassesRoot,IntPtr.Zero);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OverRideRegistry.OverrideRegistryKey(OverRideRegistry.HkeyCurrentUser,IntPtr.Zero);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OverRideRegistry.OverrideRegistryKey(OverRideRegistry.HkeyLocalMachine,IntPtr.Zero);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OverRideRegistry.OverrideRegistryKey(OverRideRegistry.HkeyUsers,IntPtr.Zero);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P><br /><P class=cl>I then parse two command line arguments one for the DLL and another for the REG file to export. I then pass these as constructors to my class, which calls these functions. </P><br /><DIV class=cf><br /><P class=cl>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> RegSpyCOMInterop(<SPAN class=cb1><FONT color=#0000ff>string</FONT></SPAN> AssemblyPath, <SPAN class=cb1><FONT color=#0000ff>string</FONT></SPAN> RegFile)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>try<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Assembly a=Assembly.LoadFrom(AssemblyPath);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegistrationServices regServices=<SPAN class=cb1><FONT color=#0000ff>new</FONT></SPAN> RegistrationServices();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//map hives to registry keys<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapRegHives();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//Register assembly for COM interop<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regServices.RegisterAssembly(a,AssemblyRegistrationFlags.SetCodeBase);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb2><FONT color=#008000>//Unmap hives<BR></FONT></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UnMapRegHives();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WriteToRegFile(RegFile);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>catch</FONT></SPAN>(Exception e)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine("Caught Exception : " + e.Message);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P><br /><P class=cl>The WriteToRegFile() function launches regedit and exports the hive that contains our keys. It then uses simple text replacement to change the values of the exported file to make the REG file functional.</P><br /><DIV class=cf><br /><P class=cl>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> <SPAN class=cb1><FONT color=#0000ff>void</FONT></SPAN> WriteToRegFile(<SPAN class=cb1><FONT color=#0000ff>string</FONT></SPAN> regfile)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegistryKey r=Registry.LocalMachine.OpenSubKey(RegLocation,<SPAN class=cb1><FONT color=#0000ff>false</FONT></SPAN>);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PathToDelete=r.Name + "\\";<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Process pr=<SPAN class=cb1><FONT color=#0000ff>new</FONT></SPAN> Process();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr.StartInfo.FileName="regedit";<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr.StartInfo.Arguments=" /e " + regfile + " " + r.Name;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr.Start();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr.WaitForExit();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>string</FONT></SPAN> line;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StreamReader reader=<SPAN class=cb1><FONT color=#0000ff>new</FONT></SPAN> StreamReader(regfile);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StreamWriter writer=<SPAN class=cb1><FONT color=#0000ff>new</FONT></SPAN> StreamWriter("TempFile.txt");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>while</FONT></SPAN>((line=reader.ReadLine())!=<SPAN class=cb1><FONT color=#0000ff>null</FONT></SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writer.WriteLine(processRegistryName(line));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reader.Close();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writer.Close();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File.Copy("TempFile.txt",regfile,<SPAN class=cb1><FONT color=#0000ff>true</FONT></SPAN>);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File.Delete("TempFile.txt");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.Flush();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.Close();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P><br /><P class=cl>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>public</FONT></SPAN> String processRegistryName(<SPAN class=cb1><FONT color=#0000ff>string</FONT></SPAN> regname)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>string</FONT></SPAN> newRegName="";<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newRegName=regname.Replace(PathToDelete,"");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newRegName=newRegName.Replace("[" + PathToDelete.Substring(0,PathToDelete.Length-1) + "]","");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newRegName=newRegName.Replace("HKCR","HKEY_CLASS_ROOT");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newRegName=newRegName.Replace("HKCU","HKEY_CURRENT_USER");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newRegName=newRegName.Replace("HKLM","HKEY_LOCAL_MACHINE");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newRegName=newRegName.Replace("HKU","HKEY_USERS");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cb1><FONT color=#0000ff>return</FONT></SPAN> newRegName;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P><br /><P class=cl>There you have it. A command line utility to extract COM Interop Registry entries. Hope this answered some of your queries regarding registration without affecting the target system. You can find the entire source code at <A href="http://www.geekswithblogs.net/vagmi.mudumbai/articles/16581.aspx">http://www.geekswithblogs.net/vagmi.mudumbai/articles/16581.aspx</A>.</P></DIV></DIV></DIV></DIV></div>
